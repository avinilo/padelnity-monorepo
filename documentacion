### **Parte 1: La Fundación - Configuración del Monorepo y Supabase**

**Objetivo de esta parte:** Crear la estructura de nuestro proyecto monorepo, configurar el backend en Supabase con las tablas y roles necesarios, y habilitar los proveedores de autenticación. Al final de esta parte, tendremos una base sólida lista para empezar a desarrollar la aplicación web.

#### **1. Tecnologías Definitivas**

Este será nuestro stack tecnológico final para todo el proyecto:

  * **Monorepo:** **Turborepo** (Rápido, moderno y fácil de usar para gestionar nuestros múltiples proyectos).
  * **Aplicación Web:** **Next.js** (con TypeScript).
  * **Aplicación Móvil:** **React Native con Expo** (Expo simplifica enormemente el desarrollo y la compilación).
  * **Backend y Autenticación:** **Supabase** (Base de datos PostgreSQL, Auth, Almacenamiento y Edge Functions).
  * **Pagos:** **Stripe**.
  * **UI Web (Recomendado):** **shadcn/ui** y **Tailwind CSS**. Es un set de componentes de UI modernos y accesibles que se integran a la perfección con Next.js.
  * **Gestión de Estado (Opcional):** **Zustand**. Una librería simple y potente para gestionar el estado global, ideal para compartir lógica entre componentes.

#### **2. Flujo de Autenticación Completo (El Plan)**

Este es el flujo que implementaremos para cualquier usuario, ya sea en la web o en el móvil:

1.  **UI (El Inicio):** El usuario ve las opciones: "Continuar con Google", "Continuar con Apple", o un formulario de email/contraseña.
2.  **SDK de Supabase:** Al hacer clic, nuestra UI llama a la función correspondiente del cliente de Supabase (ej: `supabase.auth.signInWithOAuth({ provider: 'google' })`).
3.  **Magia de Supabase (Backend):**
      * Para Google/Apple, Supabase gestiona la redirección al proveedor, la autenticación del usuario y la vuelta a nuestra aplicación.
      * Supabase crea el nuevo usuario en su tabla `auth.users`.
4.  **Trigger en la Base de Datos (Nuestra Lógica):** En el instante en que se crea el usuario en `auth.users`, un **trigger** que vamos a crear se dispara automáticamente.
5.  **Creación del Perfil:** El trigger ejecuta una función que crea una fila en nuestra tabla pública `profiles`, asociando el nuevo `id` de usuario y asignándole el rol por defecto ('jugador').
6.  **Sesión en el Cliente:** El SDK de Supabase en nuestra app recibe la sesión del usuario. La aplicación ya sabe quién es, qué rol tiene y puede mostrar la interfaz de usuario correspondiente (ej: "Bienvenido, Juan" o el dashboard del club).

#### **3. ¡A Construir\! Paso a Paso**

**Paso 1: Configurar el Proyecto de Supabase**

1.  Ve a [supabase.com](https://supabase.com), regístrate y crea un **Nuevo Proyecto**. Elige un nombre y una región cercana (ej: `eu-central-1` para Frankfurt).

2.  Una vez creado el proyecto, ve a `Settings` \> `API`. Guarda en un lugar seguro tu **Project URL** y tu **`anon` public key**. Las necesitaremos en breve.

3.  **Crear la Base de Datos (Tablas y Roles):**

      * Ve a `SQL Editor` en el menú de la izquierda.
      * Haz clic en `+ New query`.
      * Pega y ejecuta el siguiente código SQL. Este script es la base de toda nuestra aplicación.

    <!-- end list -->

    ```sql
    -- 1. CREAR UN TIPO ENUMERADO PARA LOS ROLES
    -- Esto asegura que la columna 'role' solo pueda tener estos valores.
    CREATE TYPE public.user_role AS ENUM ('jugador', 'club');

    -- 2. CREAR LA TABLA 'profiles'
    -- Esta tabla almacenará datos públicos de los usuarios.
    CREATE TABLE public.profiles (
      id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
      role public.user_role NOT NULL DEFAULT 'jugador',
      full_name TEXT,
      avatar_url TEXT
    );

    -- 3. HABILITAR LA SEGURIDAD A NIVEL DE FILA (RLS) PARA LA TABLA 'profiles'
    ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

    -- 4. CREAR POLÍTICAS DE ACCESO PARA 'profiles'
    -- Permite a cualquier persona leer los perfiles (son públicos).
    CREATE POLICY "Public profiles are viewable by everyone."
      ON public.profiles FOR SELECT
      USING (true);

    -- Permite a un usuario actualizar su propio perfil.
    CREATE POLICY "Users can update their own profile."
      ON public.profiles FOR UPDATE
      USING (auth.uid() = id);

    -- 5. CREAR LA FUNCIÓN TRIGGER QUE SE EJECUTARÁ AL CREAR UN USUARIO
    -- Esta función inserta una nueva fila en 'profiles' para cada nuevo usuario registrado.
    CREATE OR REPLACE FUNCTION public.handle_new_user()
    RETURNS TRIGGER
    LANGUAGE plpgsql
    SECURITY DEFINER SET search_path = public
    AS $$
    BEGIN
      INSERT INTO public.profiles (id, role)
      VALUES (new.id, 'jugador'); -- Por defecto, todos son 'jugador'
      RETURN new;
    END;
    $$;

    -- 6. ASIGNAR EL TRIGGER A LA TABLA DE AUTENTICACIÓN
    -- Este trigger llama a la función 'handle_new_user' cada vez que se añade un nuevo usuario.
    CREATE TRIGGER on_auth_user_created
      AFTER INSERT ON auth.users
      FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();

    ```

4.  **Habilitar Autenticación con Google y Apple:**

      * En el menú de Supabase, ve a `Authentication` \> `Providers`.
      * Verás una lista de proveedores. Activa **Google**. Supabase te proporcionará una **URL de redirección**. Necesitarás esta URL para configurar tu proyecto en la Google Cloud Console y obtener un `Client ID` y `Client Secret`. Pega estos valores de vuelta en Supabase. Sigue la [guía oficial de Supabase para Google](https://supabase.com/docs/guides/auth/social-login/auth-google) para este paso.
      * Activa **Apple** y sigue el mismo proceso con la consola de desarrolladores de Apple para obtener las credenciales necesarias. [Guía oficial de Supabase para Apple](https://supabase.com/docs/guides/auth/social-login/auth-apple).

**Paso 2: Crear la Estructura del Monorepo con Turborepo**

Abre tu terminal y ejecuta el siguiente comando. Esto creará una nueva carpeta con una estructura de monorepo lista para usar.

```bash
npx create-turbo@latest mi-red-social
```

Sigue las instrucciones y cuando termine, entra en la nueva carpeta:

```bash
cd mi-red-social
```

La estructura inicial será algo así:

```
/
├── apps
│   ├── docs  <-- La borraremos
│   └── web   <-- Será nuestra app de Next.js
└── packages
    ├── eslint-config-custom
    └── tsconfig
```

Ahora, vamos a adaptar esta estructura:

1.  **Borra la app de `docs`:**

    ```bash
    rm -rf apps/docs
    ```

2.  **Renombra `web` a `next-app` para mayor claridad:**

    ```bash
    mv apps/web apps/next-app
    ```

3.  **Crea el placeholder para la app móvil:**

    ```bash
    mkdir apps/expo-app
    ```

4.  Abre el fichero `package.json` de la raíz del proyecto y en la sección `workspaces`, asegúrate de que el path a la app renombrada es correcto. También elimina la referencia a `docs`. Debería quedar así:

    ```json
    "workspaces": [
      "apps/*",
      "packages/*"
    ]
    ```

**Paso 3: Configurar Variables de Entorno en la App de Next.js**

1.  Dentro de tu nueva app de Next.js, crea un fichero para las variables de entorno. Este fichero **no se debe subir a Git**.

    ```bash
    touch apps/next-app/.env.local
    ```

2.  Abre `apps/next-app/.env.local` y añade las claves de tu proyecto de Supabase que guardaste antes:

    ```
    NEXT_PUBLIC_SUPABASE_URL="AQUÍ_TU_PROJECT_URL_DE_SUPABASE"
    NEXT_PUBLIC_SUPABASE_ANON_KEY="AQUÍ_TU_ANON_PUBLIC_KEY_DE_SUPABASE"
    ```

    El prefijo `NEXT_PUBLIC_` es crucial. Le dice a Next.js que estas variables son seguras para ser expuestas en el navegador.

-----



En esta segunda parte, nos centraremos exclusivamente en la **aplicación web (`apps/next-app`)**. Crearemos la interfaz de usuario para el inicio de sesión, implementaremos la lógica para comunicarnos con Supabase y gestionaremos la sesión del usuario en toda la aplicación.

-----

### **Parte 2: Construcción de la Autenticación en la Web (Next.js)**

**Objetivo de esta parte:** Crear una página de login funcional con opciones de email/contraseña, Google y Apple. Proteger rutas para que solo usuarios autenticados puedan acceder y mostrar dinámicamente el estado del usuario (logueado/no logueado) en la UI.

#### **Paso 1: Instalar Dependencias**

Primero, necesitamos la librería de Supabase para React, que está optimizada para el renderizado en servidor y cliente de Next.js. Abre una terminal en la raíz de tu monorepo (`mi-red-social`) y ejecuta:

```bash
npm install @supabase/ssr @supabase/auth-helpers-nextjs --workspace=next-app
```

  * `@supabase/ssr`: La nueva librería principal para manejar la autenticación en entornos de renderizado de servidor.
  * `@supabase/auth-helpers-nextjs`: Provee helpers adicionales que simplifican el uso con Next.js.

#### **Paso 2: Crear el Cliente de Supabase**

Para usar Supabase de forma segura y eficiente en el App Router de Next.js, crearemos dos funciones para inicializar el cliente: una para componentes de cliente (que se ejecutan en el navegador) y otra para componentes de servidor (que se ejecutan en el backend).

1.  Crea una nueva carpeta: `apps/next-app/utils/supabase`.
2.  Dentro de esa carpeta, crea dos ficheros: `client.ts` y `server.ts`.

**`apps/next-app/utils/supabase/client.ts`** (Para el navegador)

```typescript
// utils/supabase/client.ts
import { createBrowserClient } from '@supabase/ssr'

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  )
}
```

**`apps/next-app/utils/supabase/server.ts`** (Para el servidor)

```typescript
// utils/supabase/server.ts
import { createServerClient, type CookieOptions } from '@supabase/ssr'
import { cookies } from 'next/headers'

export function createClient() {
  const cookieStore = cookies()

  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value
        },
        set(name: string, value: string, options: CookieOptions) {
          try {
            cookieStore.set({ name, value, ...options })
          } catch (error) {
            // The `set` method was called from a Server Component.
            // This can be ignored if you have middleware refreshing
            // user sessions.
          }
        },
        remove(name: string, options: CookieOptions) {
          try {
            cookieStore.set({ name, value: '', ...options })
          } catch (error) {
            // The `delete` method was called from a Server Component.
            // This can be ignored if you have middleware refreshing
            // user sessions.
          }
        },
      },
    }
  )
}
```

Esto nos da una forma estandarizada y segura de acceder a Supabase desde cualquier parte de nuestra app de Next.js.

#### **Paso 3: Crear el Proveedor de Autenticación (Auth Context)**

Necesitamos una forma de saber en toda la aplicación si el usuario está logueado. Usaremos el Context de React para esto.

1.  Crea el fichero `apps/next-app/app/auth-provider.tsx`.
2.  Pega el siguiente código.

<!-- end list -->

```tsx
// app/auth-provider.tsx
"use client";

import { createContext, useContext, useEffect, useState } from 'react';
import { createClient } from '@/utils/supabase/client';
import type { SupabaseClient, Session } from '@supabase/supabase-js';

type SupabaseContextType = {
  supabase: SupabaseClient;
  session: Session | null;
};

const SupabaseContext = createContext<SupabaseContextType | null>(null);

export default function SupabaseProvider({ children }: { children: React.ReactNode }) {
  const supabase = createClient();
  const [session, setSession] = useState<Session | null>(null);

  useEffect(() => {
    // Inicialmente, obtenemos la sesión
    supabase.auth.getSession().then(({ data: { session } }) => {
      setSession(session);
    });

    // Escuchamos cambios en el estado de autenticación
    const { data: { subscription } } = supabase.auth.onAuthStateChange(
      (_event, session) => {
        setSession(session);
      }
    );

    // Limpiamos la suscripción cuando el componente se desmonta
    return () => {
      subscription.unsubscribe();
    };
  }, [supabase]);

  return (
    <SupabaseContext.Provider value={{ supabase, session }}>
      {children}
    </SupabaseContext.Provider>
  );
}

// Hook personalizado para usar el contexto de Supabase fácilmente
export const useSupabase = () => {
  const context = useContext(SupabaseContext);
  if (context === null) {
    throw new Error('useSupabase must be used within a SupabaseProvider');
  }
  return context;
};
```

#### **Paso 4: Integrar el Proveedor en la Aplicación**

Ahora, hagamos que este contexto esté disponible en toda la app.

1.  Abre el layout principal: `apps/next-app/app/layout.tsx`.
2.  Importa y envuelve el `<body>` con `SupabaseProvider`.

<!-- end list -->

```tsx
// app/layout.tsx
import SupabaseProvider from './auth-provider';
import './globals.css'; // Asegúrate de que este import existe

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body>
        <SupabaseProvider>
          {children}
        </SupabaseProvider>
      </body>
    </html>
  );
}
```

#### **Paso 5: Crear la Página y Componentes de Login**

1.  Crea la ruta para el login: `apps/next-app/app/login/page.tsx`.

    ```tsx
    // app/login/page.tsx
    import AuthForm from './auth-form';

    export default function LoginPage() {
      return (
        <div className="flex justify-center items-center h-screen">
          <div className="w-full max-w-sm p-8 space-y-6 bg-white rounded-lg shadow-md">
            <h1 className="text-2xl font-bold text-center">Inicia Sesión</h1>
            <AuthForm />
          </div>
        </div>
      );
    }
    ```

2.  Ahora, crea el componente principal del formulario: `apps/next-app/app/login/auth-form.tsx`. Aquí es donde estará toda la lógica de los botones.

    ```tsx
    // app/login/auth-form.tsx
    "use client";

    import { useSupabase } from '@/app/auth-provider';
    import { useState } from 'react';

    export default function AuthForm() {
      const { supabase } = useSupabase();
      const [email, setEmail] = useState('');
      const [password, setPassword] = useState('');
      const [error, setError] = useState<string | null>(null);

      const handleGoogleLogin = async () => {
        const { error } = await supabase.auth.signInWithOAuth({
          provider: 'google',
          options: {
            redirectTo: `${location.origin}/auth/callback`, // Supabase necesita saber a dónde volver
          },
        });
        if (error) setError(error.message);
      };
      
      const handleAppleLogin = async () => {
        const { error } = await supabase.auth.signInWithOAuth({
          provider: 'apple',
          options: {
            redirectTo: `${location.origin}/auth/callback`,
          },
        });
        if (error) setError(error.message);
      };

      const handleSignUp = async (e: React.FormEvent) => {
        e.preventDefault();
        const { error } = await supabase.auth.signUp({ email, password });
        if (error) {
            setError(error.message);
        } else {
            // Podrías mostrar un mensaje de "Revisa tu email para verificar"
            setError("¡Registro exitoso! Por favor, verifica tu email.");
        }
      };
      
      const handleSignIn = async (e: React.FormEvent) => {
        e.preventDefault();
        const { error } = await supabase.auth.signInWithPassword({ email, password });
        if (error) setError(error.message);
        // La redirección ocurrirá automáticamente por el cambio de estado en el provider
      };

      return (
        <div className="space-y-4">
          {error && <p className="text-red-500 text-center">{error}</p>}
          
          {/* Social Logins */}
          <button onClick={handleGoogleLogin} className="w-full px-4 py-2 font-bold text-white bg-red-600 rounded hover:bg-red-700">Continuar con Google</button>
          <button onClick={handleAppleLogin} className="w-full px-4 py-2 font-bold text-white bg-black rounded hover:bg-gray-800">Continuar con Apple</button>
          
          <div className="text-center my-4">o</div>
          
          {/* Email/Password Form */}
          <form className="space-y-4">
            <input
              type="email"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              placeholder="Email"
              className="w-full px-3 py-2 border rounded"
            />
            <input
              type="password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              placeholder="Contraseña"
              className="w-full px-3 py-2 border rounded"
            />
            <div className="flex space-x-2">
              <button onClick={handleSignIn} className="flex-1 px-4 py-2 font-bold text-white bg-blue-500 rounded hover:bg-blue-600">Iniciar Sesión</button>
              <button onClick={handleSignUp} className="flex-1 px-4 py-2 font-bold text-gray-800 bg-gray-200 rounded hover:bg-gray-300">Registrarse</button>
            </div>
          </form>
        </div>
      );
    }
    ```

    **Nota Importante:** Para que las redirecciones de Google/Apple funcionen, necesitas añadir la URL de callback a la lista de URLs permitidas en tu dashboard de Supabase: `Authentication` \> `URL Configuration` \> `Redirect URLs`. La URL sería: `http://localhost:3000/auth/callback`.

#### **Paso 6: Proteger Rutas y Mostrar el Estado del Usuario**

1.  **Crea una página protegida:** `apps/next-app/app/account/page.tsx`. Esta página usará nuestro cliente de **servidor**.

    ```tsx
    // app/account/page.tsx
    import { createClient } from '@/utils/supabase/server';
    import { redirect } from 'next/navigation';

    export default async function AccountPage() {
      const supabase = createClient();

      const { data: { session } } = await supabase.auth.getSession();

      if (!session) {
        redirect('/login');
      }

      // Si hay sesión, podemos obtener el perfil del usuario
      const { data: profile } = await supabase
        .from('profiles')
        .select('*')
        .eq('id', session.user.id)
        .single();

      return (
        <div className="p-8">
          <h1 className="text-2xl font-bold">Página de Cuenta</h1>
          <p>Bienvenido, {session.user.email}</p>
          <p>Tu rol es: <strong>{profile?.role}</strong></p>
          <pre className="mt-4 p-4 bg-gray-100 rounded">
            {JSON.stringify(session, null, 2)}
          </pre>
        </div>
      );
    }
    ```

2.  **Crea un botón de Logout y actualiza la UI:** Vamos a crear un componente de cabecera simple.

      * Crea el fichero `apps/next-app/components/Header.tsx`.

    <!-- end list -->

    ```tsx
    // components/Header.tsx
    "use client";

    import { useSupabase } from '@/app/auth-provider';
    import Link from 'next/link';
    import { useRouter } from 'next/navigation';

    export default function Header() {
      const { session, supabase } = useSupabase();
      const router = useRouter();

      const handleLogout = async () => {
        await supabase.auth.signOut();
        router.push('/'); // Redirigir a la página principal tras cerrar sesión
      };
      
      return (
        <header className="flex items-center justify-between p-4 bg-gray-800 text-white">
          <Link href="/" className="font-bold">Mi Red Social</Link>
          <nav className="flex items-center space-x-4">
            {session ? (
              <>
                <Link href="/account">Mi Cuenta</Link>
                <button onClick={handleLogout} className="px-3 py-1 bg-red-500 rounded">Logout</button>
              </>
            ) : (
              <Link href="/login">Login</Link>
            )}
          </nav>
        </header>
      );
    }
    ```

3.  **Añade el Header al `layout.tsx`:**

    ```tsx
    // app/layout.tsx
    import SupabaseProvider from './auth-provider';
    import Header from '@/components/Header'; // Importa el nuevo componente
    import './globals.css';

    export default function RootLayout({
      children,
    }: {
      children: React.ReactNode;
    }) {
      return (
        <html lang="en">
          <body>
            <SupabaseProvider>
              <Header /> {/* Añade el Header aquí */}
              <main>{children}</main>
            </SupabaseProvider>
          </body>
        </html>
      );
    }
    ```

-----


En esta tercera parte, nos centraremos al 100% en la carpeta `apps/expo-app`. Construiremos las pantallas nativas, configuraremos la navegación y conectaremos la app móvil a nuestro backend de Supabase existente.

-----

### **Parte 3: Autenticación Nativa en la App Móvil (React Native + Expo)**

**Objetivo de esta parte:** Inicializar un proyecto de React Native con Expo, implementar el flujo de autenticación completo (Email, Google, Apple) y establecer una navegación que separe las rutas públicas de las protegidas.

#### **Paso 1: Inicializar el Proyecto Expo**

Actualmente, la carpeta `apps/expo-app` está vacía. Vamos a crear un proyecto de Expo dentro de ella.

1.  Abre tu terminal y navega hasta el directorio de la aplicación móvil:
    ```bash
    cd apps/expo-app
    ```
2.  Ahora, inicializa un nuevo proyecto de Expo en el directorio actual (el `.` es importante):
    ```bash
    npx create-expo-app .
    ```
3.  Cuando te pregunte, elige la plantilla **"Blank (TypeScript)"**. Expo instalará todas las dependencias básicas.

#### **Paso 2: Instalar Dependencias Específicas**

Necesitamos varias librerías para la navegación, el almacenamiento seguro y la comunicación con Supabase.

1.  Asegúrate de estar en el directorio `apps/expo-app`.
2.  Usa `npx expo install` para instalar las librerías de navegación. Usar `expo install` en lugar de `npm install` garantiza que obtienes versiones compatibles con tu SDK de Expo.
    ```bash
    npx expo install @react-navigation/native react-native-screens react-native-safe-area-context @react-navigation/native-stack expo-web-browser expo-linking
    ```
3.  Ahora, instala el resto de dependencias con `npm` (o el gestor de paquetes de tu monorepo):
    ```bash
    npm install @supabase/supabase-js @react-native-async-storage/async-storage react-native-url-polyfill
    ```

#### **Paso 3: Configurar Supabase y Variables de Entorno en Expo**

1.  **Crea el fichero de entorno:** Dentro de `apps/expo-app`, crea un fichero llamado `.env`.

    ```bash
    touch .env
    ```

2.  **Añade tus claves de Supabase.** Expo usa el prefijo `EXPO_PUBLIC_` para exponer variables al cliente.

    ```
    EXPO_PUBLIC_SUPABASE_URL="AQUÍ_TU_PROJECT_URL_DE_SUPABASE"
    EXPO_PUBLIC_SUPABASE_ANON_KEY="AQUÍ_TU_ANON_PUBLIC_KEY_DE_SUPABASE"
    ```

3.  **Crea el cliente de Supabase para React Native.** Este cliente es ligeramente diferente al de la web porque necesita usar `AsyncStorage` para guardar la sesión.

      * Crea la carpeta y el fichero: `apps/expo-app/utils/supabase.ts`.
      * Pega el siguiente código:

    <!-- end list -->

    ```ts
    // utils/supabase.ts
    import 'react-native-url-polyfill/auto';
    import AsyncStorage from '@react-native-async-storage/async-storage';
    import { createClient } from '@supabase/supabase-js';

    const supabaseUrl = process.env.EXPO_PUBLIC_SUPABASE_URL;
    const supabaseAnonKey = process.env.EXPO_PUBLIC_SUPABASE_ANON_KEY;

    if (!supabaseUrl || !supabaseAnonKey) {
      throw new Error("Supabase URL or Anon Key is missing in environment variables.");
    }

    export const supabase = createClient(supabaseUrl, supabaseAnonKey, {
      auth: {
        storage: AsyncStorage,
        autoRefreshToken: true,
        persistSession: true,
        detectSessionInUrl: false, // Fundamental para React Native
      },
    });
    ```

4.  **Configura Deep Linking para OAuth (Google/Apple).** El inicio de sesión con redes sociales en móvil funciona abriendo un navegador; cuando termina, debe saber cómo "volver" a tu app. Esto se hace con un "esquema de URL" personalizado.

      * Abre el fichero `apps/expo-app/app.json`.
      * Añade una clave `scheme` dentro de la sección `expo`.

    <!-- end list -->

    ```json
    {
      "expo": {
        "name": "expo-app",
        "slug": "expo-app",
        // ... otras propiedades
        "scheme": "mi-red-social" // <--- AÑADE ESTA LÍNEA
      }
    }
    ```

      * **Acción Requerida:** Ahora ve a tu dashboard de Supabase \> `Authentication` \> `URL Configuration` y en `Redirect URLs`, añade la nueva URL: `mi-red-social://auth/callback`.

#### **Paso 4: Estructurar la Navegación y Sesión**

Usaremos **Expo Router**, el sistema de rutas basado en ficheros que viene por defecto. La idea es simple: si hay una sesión activa, muestras las pantallas de la app; si no, muestras las de autenticación.

1.  **Crea un Contexto de Sesión.** Al igual que en la web, esto nos permite acceder al estado del usuario desde cualquier parte de la app.

      * Crea el fichero `apps/expo-app/context/SessionProvider.tsx`.
      * Pega el siguiente código:

    <!-- end list -->

    ```tsx
    // context/SessionProvider.tsx
    import React, { useState, useEffect, createContext, useContext } from 'react';
    import { Session } from '@supabase/supabase-js';
    import { supabase } from '@/utils/supabase';

    type SessionContextType = {
      session: Session | null;
      isLoading: boolean;
    };

    const SessionContext = createContext<SessionContextType | null>(null);

    export function SessionProvider({ children }: { children: React.ReactNode }) {
      const [session, setSession] = useState<Session | null>(null);
      const [isLoading, setIsLoading] = useState(true);

      useEffect(() => {
        supabase.auth.getSession().then(({ data: { session } }) => {
          setSession(session);
          setIsLoading(false);
        });

        const { data: { subscription } } = supabase.auth.onAuthStateChange((_event, session) => {
          setSession(session);
        });

        return () => subscription.unsubscribe();
      }, []);

      return (
        <SessionContext.Provider value={{ session, isLoading }}>
          {children}
        </SessionContext.Provider>
      );
    }

    // Hook para usar el contexto fácilmente
    export const useSession = () => {
      const context = useContext(SessionContext);
      if (context === null) {
        throw new Error('useSession must be used within a SessionProvider');
      }
      return context;
    };
    ```

2.  **Configura el Layout Principal.** Aquí decidiremos qué pantallas mostrar. Expo Router usa `_layout.tsx` como el "envoltorio" de un directorio.

      * Renombra el `app/_layout.tsx` que exista (si existe) y/o crea la siguiente estructura de carpetas y ficheros dentro de `apps/expo-app/app`:
          * `app/(app)/_layout.tsx` (Layout para las pantallas protegidas)
          * `app/(app)/home.tsx` (Nuestra pantalla de inicio)
          * `app/(auth)/_layout.tsx` (Layout para las pantallas de login)
          * `app/(auth)/login.tsx` (Nuestra pantalla de login)
          * `app/_layout.tsx` (El layout raíz y principal)

3.  **Rellena el Layout Raíz (`app/_layout.tsx`):**

    ```tsx
    // app/_layout.tsx
    import { SessionProvider, useSession } from '@/context/SessionProvider';
    import { Stack } from 'expo-router';
    import { Redirect } from 'expo-router';
    import { Text } from 'react-native';

    function RootLayoutNav() {
      const { session, isLoading } = useSession();

      if (isLoading) {
        // Podrías mostrar un Splash Screen aquí
        return <Text>Loading...</Text>;
      }

      // Si no hay sesión, el usuario es redirigido a las pantallas del grupo (auth)
      if (!session) {
        return <Redirect href="/login" />;
      }
      
      // Si hay sesión, el usuario es redirigido a las pantallas del grupo (app)
      return <Redirect href="/home" />;
    }

    export default function RootLayout() {
      return (
        <SessionProvider>
            <RootLayoutNav />
        </SessionProvider>
      );
    }
    ```

    *Esta configuración es incorrecta, el layout debe devolver un componente de navegación*

    **CORRECCIÓN:** La lógica de redirección se maneja mejor con el enrutador. El `_layout.tsx` raíz debe configurar el `Stack` y el proveedor.

    **Código Correcto para `app/_layout.tsx`:**

    ```tsx
    // app/_layout.tsx
    import { SessionProvider, useSession } from '@/context/SessionProvider';
    import { Slot, useRouter, useSegments } from 'expo-router';
    import { useEffect } from 'react';
    import { Text, View } from 'react-native';

    function InitialLayout() {
      const { session, isLoading } = useSession();
      const segments = useSegments();
      const router = useRouter();

      useEffect(() => {
        if (isLoading) return;

        const inAuthGroup = segments[0] === '(auth)';

        if (session && inAuthGroup) {
          // Redirigir a la home si el usuario está logueado y en las pantallas de auth
          router.replace('/home');
        } else if (!session && !inAuthGroup) {
          // Redirigir al login si el usuario no está logueado y fuera de las pantallas de auth
          router.replace('/login');
        }
      }, [session, isLoading, segments]);

      if (isLoading) {
        return <View><Text>Loading...</Text></View>
      }

      return <Slot />;
    }

    export default function RootLayout() {
      return (
        <SessionProvider>
          <InitialLayout />
        </SessionProvider>
      );
    }
    ```

    Esta es la forma canónica de proteger rutas con Expo Router v2/v3.

4.  **Define los layouts de los grupos:**

      * `app/(app)/_layout.tsx`:

    <!-- end list -->

    ```tsx
    import { Stack } from 'expo-router';
    export default function AppLayout() {
      return <Stack />;
    }
    ```

      * `app/(auth)/_layout.tsx`:

    <!-- end list -->

    ```tsx
    import { Stack } from 'expo-router';
    export default function AuthLayout() {
      return <Stack screenOptions={{ headerShown: false }} />;
    }
    ```

#### **Paso 5: Crear la Pantalla de Login**

Ahora creamos la UI y la lógica para `app/(auth)/login.tsx`.

```tsx
// app/(auth)/login.tsx
import { useState } from 'react';
import { supabase } from '@/utils/supabase';
import { View, TextInput, Button, Alert, StyleSheet, Text } from 'react-native';
import * as WebBrowser from 'expo-web-browser';
import * as Linking from 'expo-linking';

// Necesario para el flujo de OAuth en móvil
WebBrowser.maybeCompleteAuthSession();

export default function LoginScreen() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');

  const handleGoogleLogin = async () => {
    const { data, error } = await supabase.auth.signInWithOAuth({
      provider: 'google',
      options: {
        redirectTo: Linking.createURL('auth/callback'),
      },
    });

    if (error) {
      Alert.alert('Error', error.message);
    } else if (data.url) {
      await WebBrowser.openAuthSessionAsync(data.url);
    }
  };

  const handleSignIn = async () => {
    const { error } = await supabase.auth.signInWithPassword({ email, password });
    if (error) Alert.alert('Error', error.message);
    // La redirección es manejada por el RootLayout
  };

  const handleSignUp = async () => {
    const { error } = await supabase.auth.signUp({ email, password });
    if (error) Alert.alert('Error', error.message);
    else Alert.alert('Éxito', 'Revisa tu email para la verificación!');
  };

  return (
    <View style={styles.container}>
      <Text style={styles.header}>Mi Red Social</Text>
      <TextInput
        style={styles.input}
        placeholder="Email"
        value={email}
        onChangeText={setEmail}
        autoCapitalize="none"
      />
      <TextInput
        style={styles.input}
        placeholder="Contraseña"
        value={password}
        onChangeText={setPassword}
        secureTextEntry
      />
      <View style={styles.buttonContainer}>
        <Button title="Iniciar Sesión" onPress={handleSignIn} />
        <Button title="Registrarse" onPress={handleSignUp} />
      </View>
      <View style={styles.separator} />
      <Button title="Continuar con Google" onPress={handleGoogleLogin} />
      {/* El botón de Apple requiere configuración adicional de capacidades en XCode */}
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, justifyContent: 'center', padding: 16 },
  header: { fontSize: 24, fontWeight: 'bold', textAlign: 'center', marginBottom: 20 },
  input: { borderWidth: 1, borderColor: 'gray', padding: 10, borderRadius: 5, marginBottom: 10 },
  buttonContainer: { flexDirection: 'row', justifyContent: 'space-around', marginVertical: 10 },
  separator: { height: 20 },
});
```

#### **Paso 6: Crear la Pantalla Principal Protegida**

Finalmente, una pantalla simple para los usuarios logueados en `app/(app)/home.tsx`.

```tsx
// app/(app)/home.tsx
import { useSession } from '@/context/SessionProvider';
import { supabase } from '@/utils/supabase';
import { View, Text, Button, StyleSheet } from 'react-native';

export default function HomeScreen() {
  const { session } = useSession();

  return (
    <View style={styles.container}>
      <Text style={styles.title}>¡Bienvenido!</Text>
      <Text>User ID: {session?.user.id}</Text>
      <Text>Email: {session?.user.email}</Text>
      <View style={styles.separator} />
      <Button title="Cerrar Sesión" onPress={() => supabase.auth.signOut()} />
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, justifyContent: 'center', alignItems: 'center', padding: 16 },
  title: { fontSize: 22, fontWeight: 'bold', marginBottom: 16 },
  separator: { marginVertical: 15 },
});
```

-----

**Paso 4 Revisado**. guía de implementación de principio a fin para el sistema de perfiles y onboarding.

-----

### **Paso 4 (Revisado): Implementación del Flujo de Onboarding y Perfiles**

**Objetivo de esta parte:** Modificar la base de datos y la lógica de navegación para forzar un flujo de onboarding. Crear las pantallas para que el usuario elija su rol y complete su perfil inicial, reutilizando la lógica de edición de perfiles que ya habíamos diseñado.

#### **Sub-Paso A: Preparación del Backend (Base de Datos y Almacenamiento)**

Esto es lo primero. Son cambios únicos en tu dashboard de Supabase.

1.  **Modificar la Base de Datos:**

      * Ve a tu **SQL Editor** en Supabase.
      * Ejecuta el siguiente script para añadir la columna `onboarding_complete` y para modificar el trigger de creación de usuario, de modo que ya no asigne un rol por defecto.

    <!-- end list -->

    ```sql
    -- 1. AÑADIR LA COLUMNA PARA RASTREAR EL ONBOARDING
    ALTER TABLE public.profiles
    ADD COLUMN onboarding_complete BOOLEAN NOT NULL DEFAULT FALSE;

    -- 2. MODIFICAR LA FUNCIÓN DEL TRIGGER PARA QUITAR EL ROL POR DEFECTO
    CREATE OR REPLACE FUNCTION public.handle_new_user()
    RETURNS TRIGGER
    LANGUAGE plpgsql
    SECURITY DEFINER SET search_path = public
    AS $$
    BEGIN
      -- Inserta solo el ID. El resto se rellenará durante el onboarding.
      INSERT INTO public.profiles (id)
      VALUES (new.id);
      RETURN new;
    END;
    $$;
    ```

2.  **Configurar el Almacenamiento (Storage):**

      * Ve a **Storage** en Supabase, crea un bucket público llamado `avatars`.
      * Ve a **Authentication** \> **Policies** y crea las 3 políticas de seguridad para el bucket `avatars` que definimos en el Paso 4 original (permitir lectura pública, inserción autenticada y actualización/borrado por el propietario).

#### **Sub-Paso B: Implementar la Lógica de Redirección (El Guardián)**

Ahora forzaremos a los usuarios nuevos a pasar por el onboarding.

1.  **En la Web (`next-app`) - Middleware:**

      * Crea el fichero `apps/next-app/middleware.ts` y pega este código:

    <!-- end list -->

    ```ts
    // apps/next-app/middleware.ts
    import { createServerClient } from '@supabase/ssr'
    import { NextResponse, type NextRequest } from 'next/server'

    export async function middleware(request: NextRequest) {
      let response = NextResponse.next({ request: { headers: request.headers } })
      const supabase = createServerClient(
        process.env.NEXT_PUBLIC_SUPABASE_URL!,
        process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
        {
          cookies: {
            get: (name) => request.cookies.get(name)?.value,
            set: (name, value, options) => {
              request.cookies.set({ name, value, ...options })
              response = NextResponse.next({ request: { headers: request.headers } })
              response.cookies.set({ name, value, ...options })
            },
            remove: (name, options) => {
              request.cookies.set({ name, value: '', ...options })
              response = NextResponse.next({ request: { headers: request.headers } })
              response.cookies.set({ name, value: '', ...options })
            },
          },
        }
      )

      const { data: { session } } = await supabase.auth.getSession()

      // Si no hay sesión, no hacemos nada, las páginas se protegerán solas si es necesario.
      if (!session) return response

      // Si hay sesión, verificamos el estado del onboarding.
      const { data: profile } = await supabase.from('profiles').select('onboarding_complete').eq('id', session.user.id).single()
      const isOnboardingComplete = profile?.onboarding_complete
      const isOnboardingPage = request.nextUrl.pathname.startsWith('/onboarding')

      if (!isOnboardingComplete && !isOnboardingPage) {
        return NextResponse.redirect(new URL('/onboarding/select-role', request.url))
      } else if (isOnboardingComplete && isOnboardingPage) {
        return NextResponse.redirect(new URL('/', request.url))
      }

      return response
    }

    export const config = {
      matcher: ['/((?!_next/static|_next/image|favicon.ico|auth|login).*)'],
    }
    ```

2.  **En el Móvil (`expo-app`) - Layout Raíz:**

      * Abre `apps/expo-app/app/_layout.tsx` y reemplaza el componente `InitialLayout` con esta versión mejorada que consulta el perfil.

    <!-- end list -->

    ```tsx
    // En apps/expo-app/app/_layout.tsx
    // ... (importaciones existentes)
    import { supabase } from '@/utils/supabase'; // Importa el cliente

    function InitialLayout() {
      const { session, isLoading } = useSession();
      const segments = useSegments();
      const router = useRouter();

      useEffect(() => {
        if (isLoading) return;

        const inAuthGroup = segments[0] === '(auth)';

        if (!session) {
          // Si no hay sesión, asegurar que está en el grupo de auth
          if (!inAuthGroup) router.replace('/login');
          return;
        }

        // Si hay sesión, comprobar el onboarding
        const checkOnboarding = async () => {
          const { data: profile } = await supabase.from('profiles').select('onboarding_complete').eq('id', session.user.id).single();
          const isComplete = profile?.onboarding_complete;
          const inOnboardingFlow = segments.includes('onboarding'); // Asumiendo que las pantallas de onboarding estarán en una ruta que contenga 'onboarding'
          
          if (!isComplete && !inOnboardingFlow) {
            router.replace('/onboarding/select-role'); // Redirigir al inicio del onboarding
          } else if (isComplete && (inOnboardingFlow || inAuthGroup)) {
            router.replace('/home'); // Si ya completó, mandarle a la home
          }
        };

        checkOnboarding();

      }, [session, isLoading, segments]);

      return <Slot />;
    }
    // El resto del fichero RootLayout se queda igual
    ```

#### **Sub-Paso C: Crear las Pantallas de Onboarding**

Aquí es donde reutilizamos el código del Paso 4 original.

1.  **Pantalla de Selección de Rol (Web):**

      * Crea el fichero `apps/next-app/app/onboarding/select-role/page.tsx`.

    <!-- end list -->

    ```tsx
    // app/onboarding/select-role/page.tsx
    'use client'
    import { createClient } from '@/utils/supabase/client'
    import { useRouter } from 'next/navigation'
    import { useSupabase } from '@/app/auth-provider' // Usamos el hook del provider

    export default function SelectRolePage() {
      const { session } = useSupabase()
      const router = useRouter()
      const supabase = createClient()

      const handleSelectRole = async (role: 'jugador' | 'club') => {
        if (!session) return
        
        const { error } = await supabase.from('profiles').update({ role }).eq('id', session.user.id)
        
        if (error) {
          alert("Error guardando el rol: " + error.message)
        } else {
          // Redirigir al siguiente paso del onboarding
          if (role === 'jugador') {
            router.push('/onboarding/player-setup')
          } else {
            // A futuro, redirigir a la configuración del club
            router.push('/onboarding/club-setup') 
          }
        }
      }

      return (
        <div className="flex flex-col justify-center items-center h-screen">
          <h1 className="text-3xl font-bold mb-8">Elige tu Rol</h1>
          <div className="flex space-x-8">
            <button onClick={() => handleSelectRole('jugador')} className="px-8 py-4 bg-blue-500 text-white rounded-lg text-xl">Soy un Jugador</button>
            <button onClick={() => handleSelectRole('club')} className="px-8 py-4 bg-green-500 text-white rounded-lg text-xl">Soy un Club</button>
          </div>
        </div>
      )
    }
    ```

2.  **Pantalla de Setup del Perfil de Jugador (Web):**

      * Crea el fichero `apps/next-app/app/onboarding/player-setup/page.tsx`.
      * **Aquí usamos el código del Paso 4**, pero modificado para el onboarding.

    <!-- end list -->

    ```tsx
    // app/onboarding/player-setup/page.tsx
    'use client'
    import { useCallback, useEffect, useState } from 'react'
    import { createClient } from '@/utils/supabase/client'
    import { type User } from '@supabase/supabase-js'
    import { useSupabase } from '@/app/auth-provider'
    import { useRouter } from 'next/navigation'

    // Este componente es básicamente el AccountForm del Paso 4, adaptado.
    export default function PlayerSetupPage() {
      const { session } = useSupabase()
      const user = session?.user
      const router = useRouter()

      const supabase = createClient()
      const [loading, setLoading] = useState(true)
      const [fullname, setFullname] = useState<string | null>(null)
      const [avatar_url, setAvatarUrl] = useState<string | null>(null)
      
      // La función getProfile y uploadAvatar son idénticas a las del Paso 4 original.
      // Puedes copiarlas y pegarlas aquí.

      // La función de actualización es la que cambia:
      async function updateProfileAndCompleteOnboarding(event: React.FormEvent<HTMLFormElement>) {
        event.preventDefault()
        if (!user) return

        setLoading(true)
        const { error } = await supabase.from('profiles').upsert({
          id: user.id,
          full_name: fullname,
          avatar_url,
          onboarding_complete: true, // ¡La clave está aquí!
        })

        if (error) {
          alert('Error actualizando los datos: ' + error.message)
        } else {
          // Forzar un refresh para que el middleware detecte el cambio y redirija
          router.refresh()
        }
        setLoading(false)
      }

      // El JSX del formulario es idéntico al de AccountForm del Paso 4.
      // Puedes copiar y pegar la estructura del return aquí, asegurándote
      // de que el `onSubmit` del formulario llame a `updateProfileAndCompleteOnboarding`.

      return (
        <div>
          <h1 className="text-2xl font-bold">Configura tu Perfil de Jugador</h1>
          {/* Aquí va el JSX del formulario de perfil del Paso 4, 
              con su lógica de getProfile y uploadAvatar.
              El <form> debe tener onSubmit={updateProfileAndCompleteOnboarding} */}
        </div>
      )
    }
    ```

3.  **Implementación Móvil (`expo-app`):**

      * Sigue el mismo patrón: crea las pantallas equivalentes (`/onboarding/select-role.tsx` y `/onboarding/player-setup.tsx`).
      * La pantalla `select-role` tendrá dos botones que actualizan el rol y usan `router.replace()` para navegar.
      * La pantalla `player-setup` reutilizará el código de la pantalla `account.tsx` del Paso 4 original, pero su botón "Guardar" llamará a una función que actualice el perfil y, crucialmente, establezca `onboarding_complete: true`.

#### **Sub-Paso D: La Página "Mi Cuenta" (Post-Onboarding)**

  * **El código del Paso 4 original para la página `/account` sigue siendo válido y necesario.**
  * Su propósito es permitir que los usuarios (tanto jugadores como clubes) editen su información *después* de haber completado el onboarding.
  * **No necesitas hacerle ningún cambio.** Simplemente asegúrate de que exista una ruta `/account` donde los usuarios puedan ir a gestionar su perfil.

-----

Esta parte integra la lógica de negocio (perfiles de negocio) con los pagos (Stripe), culminando todo el trabajo de configuración que hemos hecho hasta ahora.

-----

### **Paso 5: Onboarding del Club y Suscripción con Stripe**

**Objetivo de esta parte:** Construir el flujo para un usuario que elige el rol de 'club'. Esto incluye un formulario de perfil detallado, una página de selección de planes de pago y la lógica de checkout con Stripe que, al completarse con éxito, activa finalmente la cuenta del club.

#### **Sub-Paso A: Preparación del Backend (Base de Datos y Stripe)**

Primero, necesitamos que nuestra infraestructura esté lista para los datos de los clubes y los planes de pago.

1.  **Ampliar la Tabla `profiles`:** Los clubes necesitan más campos que los jugadores. Vamos a añadirlos.

      * Ve a tu **SQL Editor** en Supabase y ejecuta este script para añadir columnas a tu tabla `profiles`.

    <!-- end list -->

    ```sql
    ALTER TABLE public.profiles
    ADD COLUMN business_name TEXT,
    ADD COLUMN website TEXT,
    ADD COLUMN address TEXT;
    -- Puedes añadir cualquier otro campo que necesites para un club
    ```

2.  **Configurar los Productos en Stripe:**

      * Ve a tu **Dashboard de Stripe**.
      * En la sección **Productos**, crea tus 3 planes de suscripción (ej: "Básico", "Pro", "Premium").
      * A cada producto, añádele un **Precio** recurrente (ej: 19€/mes).
      * **Acción crucial:** Para cada uno de los 3 precios que crees, copia su **ID de Precio** (empieza por `price_...`). Los necesitaremos en el siguiente paso.

3.  **Registrar los Planes en tu Base de Datos (Opcional, pero recomendado):**

      * La plantilla de integración de Stripe ya te creó las tablas `products` y `prices`. Para que tu app muestre los planes sin tener que pedirlos a Stripe cada vez, es una buena práctica rellenar estas tablas.
      * Ve a tu **Table Editor** en Supabase, selecciona la tabla `products` y añade tus 3 productos. Luego, en la tabla `prices`, añade los 3 precios, asegurándote de pegar el **ID de Precio** de Stripe en la columna correspondiente.

#### **Sub-Paso B: Pantallas de Onboarding del Club (Web/Next.js)**

Nos enfocaremos en la implementación web. La lógica en móvil será análoga.

1.  **Pantalla de Perfil del Club (`club-setup`):**

      * Crea la ruta y el fichero: `apps/next-app/app/onboarding/club-setup/page.tsx`.
      * Este componente contendrá un formulario con los nuevos campos que hemos añadido.

    <!-- end list -->

    ```tsx
    // app/onboarding/club-setup/page.tsx
    'use client'
    import { useState } from 'react'
    import { createClient } from '@/utils/supabase/client'
    import { useSupabase } from '@/app/auth-provider'
    import { useRouter } from 'next/navigation'

    export default function ClubSetupPage() {
      const { session } = useSupabase()
      const router = useRouter()
      const supabase = createClient()
      const [businessName, setBusinessName] = useState('')
      const [website, setWebsite] = useState('')
      // ... otros estados para otros campos

      const handleProfileUpdate = async (e: React.FormEvent) => {
        e.preventDefault()
        if (!session) return

        const { error } = await supabase.from('profiles').update({
          business_name: businessName,
          website: website,
        }).eq('id', session.user.id)

        if (error) {
          alert("Error guardando el perfil: " + error.message)
        } else {
          // Perfil guardado, redirigir a la selección de planes
          router.push('/onboarding/select-plan')
        }
      }

      return (
        <div>
          <h1 className="text-2xl font-bold">Configura el Perfil de tu Club</h1>
          <form onSubmit={handleProfileUpdate} className="space-y-4 mt-6">
            <input placeholder="Nombre del Negocio" value={businessName} onChange={(e) => setBusinessName(e.target.value)} required className="w-full px-3 py-2 border rounded" />
            <input placeholder="Sitio Web (https://...)" value={website} onChange={(e) => setWebsite(e.target.value)} className="w-full px-3 py-2 border rounded" />
            {/* El campo para subir el avatar se puede añadir aquí, reutilizando la lógica del Paso 4 Revisado */}
            <button type="submit" className="w-full px-4 py-2 font-bold text-white bg-blue-500 rounded">Guardar y Continuar</button>
          </form>
        </div>
      )
    }
    ```

2.  **Pantalla de Selección de Planes (`select-plan`):**

      * Crea la ruta y el fichero: `apps/next-app/app/onboarding/select-plan/page.tsx`.
      * Esta página obtendrá los planes de tu base de datos y mostrará un botón de "Suscribirse" para cada uno.

    <!-- end list -->

    ```tsx
    // app/onboarding/select-plan/page.tsx
    import { createClient } from '@/utils/supabase/server'
    import SubscribeButton from './subscribe-button' // Componente cliente

    export default async function SelectPlanPage() {
      const supabase = createClient()
      // Obtenemos los productos y sus precios de nuestra DB
      const { data: products } = await supabase
        .from('products')
        .select('*, prices(*)')
        .eq('active', true)
        .eq('prices.active', true)
        .order('unit_amount', { foreignTable: 'prices' })

      return (
        <div>
          <h1 className="text-3xl font-bold text-center my-8">Elige tu Plan</h1>
          <div className="flex justify-center space-x-4">
            {products?.map((product) => {
              const price = product.prices?.[0]
              if (!price) return null
              
              return (
                <div key={product.id} className="border rounded-lg p-6 w-1/3">
                  <h2 className="text-xl font-bold">{product.name}</h2>
                  <p className="text-3xl my-4">
                    {(price.unit_amount / 100).toLocaleString('es-ES', { style: 'currency', currency: 'EUR' })}
                  </p>
                  <p className="text-gray-500">{product.description}</p>
                  <SubscribeButton priceId={price.id} />
                </div>
              )
            })}
          </div>
        </div>
      )
    }
    ```

      * Ahora, el componente cliente para el botón: `apps/next-app/app/onboarding/select-plan/subscribe-button.tsx`.

    <!-- end list -->

    ```tsx
    // app/onboarding/select-plan/subscribe-button.tsx
    'use client'
    import { createCheckoutSession } from '@/app/actions/stripe' // Server Action
    import { useState } from 'react'

    export default function SubscribeButton({ priceId }: { priceId: string }) {
      const [loading, setLoading] = useState(false)

      const handleSubscription = async () => {
        setLoading(true)
        const { url } = await createCheckoutSession(priceId)
        if (url) {
          window.location.href = url
        } else {
          alert("Error creando la sesión de pago.")
          setLoading(false)
        }
      }

      return (
        <button onClick={handleSubscription} disabled={loading} className="mt-6 w-full px-4 py-2 font-bold text-white bg-green-500 rounded">
          {loading ? 'Procesando...' : 'Suscribirse'}
        </button>
      )
    }
    ```

#### **Sub-Paso C: Lógica de Checkout con Server Actions**

1.  **Instala la librería de Stripe:**

    ```bash
    npm install stripe --workspace=next-app
    ```

2.  **Crea la Server Action:** Este código seguro se ejecutará en el servidor para comunicarse con Stripe.

      * Crea el fichero `apps/next-app/app/actions/stripe.ts`.

    <!-- end list -->

    ```ts
    // app/actions/stripe.ts
    'use server'
    import { createClient } from '@/utils/supabase/server'
    import { headers } from 'next/headers'
    import { redirect } from 'next/navigation'
    import Stripe from 'stripe'

    const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {
      apiVersion: '2024-06-20',
      typescript: true,
    })

    export async function createCheckoutSession(priceId: string) {
      const supabase = createClient()
      const { data: { user } } = await supabase.auth.getUser()

      if (!user) {
        return redirect('/login')
      }

      const origin = headers().get('origin')!

      // Creamos la sesión de checkout en Stripe
      const session = await stripe.checkout.sessions.create({
        payment_method_types: ['card'],
        line_items: [{ price: priceId, quantity: 1 }],
        mode: 'subscription',
        success_url: `${origin}/`, // El usuario volverá aquí tras pagar
        cancel_url: `${origin}/onboarding/select-plan`,
        customer_email: user.email,
        // ¡Crucial! Pasamos el ID de usuario para saber a quién pertenece la suscripción en el webhook
        subscription_data: {
          metadata: {
            userId: user.id,
          },
        },
      })

      return { url: session.url }
    }
    ```

      * **No olvides** añadir tu `STRIPE_SECRET_KEY` a tus variables de entorno en Supabase (si despliegas ahí) o en tu fichero `.env.local`.

#### **Sub-Paso D: Finalizar el Webhook de Stripe**

Este es el último paso. Cuando Stripe confirma el pago, el webhook que creamos con la plantilla de Supabase se ejecuta. Necesitamos modificarlo para que complete el onboarding.

1.  Ve a `Edge Functions` en tu dashboard de Supabase y edita el código de tu función `stripe-webhook`.

2.  Busca el `switch` y el `case` que maneja eventos de suscripción (`customer.subscription.created` o `customer.subscription.updated`).

3.  **Añade el código** para actualizar la tabla `profiles`.

    ```javascript
    // Dentro de tu Edge Function (supabase/functions/stripe-webhook/index.ts)
    // ... en el case 'customer.subscription.created' o 'customer.subscription.updated'
    // Después de que el código existente haya hecho el upsert en la tabla 'subscriptions'...

    // Obtenemos el ID de usuario que pasamos en los metadatos
    const userId = subscription.metadata.userId;

    if (!userId) {
      console.error('Webhook Error: No userId found in subscription metadata.');
      return new Response('Webhook Error: No userId in metadata', { status: 400 });
    }

    // Actualizamos el perfil para marcar el onboarding como completado
    const { error: profileError } = await supabaseAdmin
      .from('profiles')
      .update({ onboarding_complete: true })
      .eq('id', userId);

    if (profileError) {
      console.error(`Webhook Error: Failed to update onboarding status for user ${userId}`, profileError);
      // Podrías devolver un error 500 para que Stripe reintente el webhook
      return new Response('Webhook Error: Could not update profile', { status: 500 });
    }

    console.log(`Successfully completed onboarding for user: ${userId}`);
    ```

      * **Importante:** Este código usa `supabaseAdmin`, un cliente de Supabase que tiene permisos de administrador para saltarse las políticas de RLS. La plantilla de integración de Stripe ya debería haberlo configurado por ti.

-----
